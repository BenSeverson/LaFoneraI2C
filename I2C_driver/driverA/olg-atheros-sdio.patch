diff -uNr empty/empty/empty/Makefile packages/utils/sdio/Makefile
--- empty/empty/empty/Makefile    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/Makefile    2007-04-24 23:14:06.322251200 +0200
@@ -0,0 +1,98 @@
+# 
+# Copyright (C) 2007 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+# $Id:$
+
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=sdio
+PKG_VERSION:=linux-2.6.18-nostd
+PKG_RELEASE:=1
+
+
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.gz
+PKG_SOURCE_URL:=@SF/sdio-linux
+PKG_MD5SUM:=02dd7c73ab99ca4bddc6c8fa4080859d
+
+PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/$(PKG_NAME)/src
+
+include $(INCLUDE_DIR)/package.mk
+
+define KernelPackage/sdio
+    SUBMENU:=Other modules
+    DEPENDS:=@LINUX_2_6_ATHEROS 
+    TITLE:=SDIO
+    
+    DESCRIPTION:=\
+     port of the SDIO-Stack (http://sourceforge.net/projects/sdio-linux/) to use with a bitbanging SPI host controller 
+     
+    VERSION:=$(LINUX_VERSION)-$(BOARD)-$(PKG_RELEASE)
+    FILES:= \
+        $(PKG_BUILD_DIR)/drivers/sdio/hcd/gpio/sdio_gpio.$(LINUX_KMOD_SUFFIX) \
+        $(PKG_BUILD_DIR)/drivers/sdio/busdriver/sdio_busdriver.$(LINUX_KMOD_SUFFIX) \
+        $(PKG_BUILD_DIR)/drivers/sdio/lib/sdio_lib.$(LINUX_KMOD_SUFFIX) \
+        $(PKG_BUILD_DIR)/drivers/sdio/function/memory/sdio_memory_fd.$(LINUX_KMOD_SUFFIX)
+        
+    ifeq ($(CONFIG_SDIO_DEBUG),y)
+        FILES += $(PKG_BUILD_DIR)/drivers/sdio/hcd/gpio/mmc_test.$(LINUX_KMOD_SUFFIX)
+    endif
+
+    ifeq ($(CONFIG_SDIO_DEBUG),y)
+        #RSTRIP:=true        #disables (!) module stripping
+        EXTRADEBUGCFLAGS:= -DDEBUG=5
+        #-DSDIO_HCD_CHECK_ZERO_PATTERN
+        #-DSDIO_MEM_CHKBUFFERINIT 
+        #-DSDIO_HCD_CHECK_IOT_PATTERN 
+        #-DSDIO_HCD_WRITE_DEBUGPATTERN 
+    endif
+    
+    #AUTOLOAD:=$(call AutoLoad,20,switch-core switch-robo switch-adm)
+    MENU:=1
+endef
+
+
+#define KernelPackage/sdio/config
+define Package/kmod-sdio/config
+    menu "SDIO config"
+        depends on PACKAGE_kmod-sdio
+        
+        config SDIO_DEBUG
+            bool "enable debugging output"
+            default y
+    
+        source "$(SOURCE)/config/Config.in"
+        source "$(SOURCE)/config/Kconfig"
+    endmenu    
+endef
+
+define Build/Prepare
+    $(call Build/Prepare/Default)
+    $(RM) -rf $(PKG_BUILD_DIR)/../src
+    mkdir -p $(PKG_BUILD_DIR)/../src
+    #$(CP) ./src/* $(PKG_BUILD_DIR)/../src    
+    cd $(PKG_BUILD_DIR)/.. ; cat `cat $(PKG_BUILD_DIR)/../series` | patch -p1 -f -r rejignore -d $(PKG_BUILD_DIR) || true
+    $(PATCH) $(PKG_BUILD_DIR)/../src ./patches2
+    $(CP) ./src/* $(PKG_BUILD_DIR)/../src
+endef
+
+
+define Build/Compile
+    $(MAKE) -C "$(LINUX_DIR)" \
+        CROSS_COMPILE="$(TARGET_CROSS)" \
+        ARCH="$(LINUX_KARCH)" \
+        CONFIG_SDIO_MEMORY=m\
+        SUBDIRS="$(PKG_BUILD_DIR)/../src" \
+        EXTRA_CFLAGS="$(EXTRADEBUGCFLAGS) -I$(PKG_BUILD_DIR)/../src/include -I$(LINUX_DIR)/arch/mips/atheros -DCONFIG_KMOD_MMC_GPIO_DI=$(CONFIG_KMOD_MMC_GPIO_DI) -DCONFIG_KMOD_MMC_GPIO_DO=$(CONFIG_KMOD_MMC_GPIO_DO) -DCONFIG_KMOD_MMC_GPIO_CLK=$(CONFIG_KMOD_MMC_GPIO_CLK) -DCONFIG_KMOD_MMC_GPIO_CS=$(CONFIG_KMOD_MMC_GPIO_CS)" \
+        modules
+endef
+
+    
+define KernelPackage/sdio/install
+    
+endef
+
+$(eval $(call KernelPackage,sdio))
diff -uNr empty/empty/empty/config/Config.in packages/utils/sdio/config/Config.in
--- empty/empty/empty/config/Config.in    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/config/Config.in    2007-02-21 20:06:23.378592000 +0100
@@ -0,0 +1,32 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+config KMOD_MMC_GPIO_DI
+    int "GPIO DI"
+    default 1 if LINUX_2_6_ATHEROS
+    default 5 if LINUX_2_6_BRCM 
+    range 0 31
+    help  
+
+config KMOD_MMC_GPIO_DO
+    int "GPIO DO"
+    default 3 if LINUX_2_6_ATHEROS
+    default 4 if LINUX_2_6_BRCM
+    help  
+    
+config KMOD_MMC_GPIO_CLK
+    int "GPIO CLK"
+    default 4 if LINUX_2_6_ATHEROS 
+    default 3 if LINUX_2_6_BRCM
+    range 0 31
+    help  
+    
+config KMOD_MMC_GPIO_CS
+    int "GPIO CS"
+    default 7 if LINUX_2_6_ATHEROS
+    default 7 if LINUX_2_6_BRCM
+    range 0 31
+    help  
+    
\ No newline at end of file
diff -uNr empty/empty/empty/config/Kconfig packages/utils/sdio/config/Kconfig
--- empty/empty/empty/config/Kconfig    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/config/Kconfig    2007-01-20 11:08:15.000000000 +0100
@@ -0,0 +1,30 @@
+
+menu "SDIO function drivers"
+
+config SDIO_BLUETOOTH
+       tristate "bluetooth over sdio"
+       default m
+       help
+    good luck.
+
+
+config SDIO_GPS
+       tristate "gps over sdio"
+       default m
+       help
+    good luck.
+
+config SDIO_MEMORY
+       tristate "memory card over sdio"
+       default m
+       help
+    good luck.
+
+config SDIO_SAMPLE
+       tristate "sample function driver for sdio"
+       default m
+       help
+    good luck.
+
+
+endmenu
diff -uNr empty/empty/empty/patches2/100-remove_obsolete_config_h.patch packages/utils/sdio/patches2/100-remove_obsolete_config_h.patch
--- empty/empty/empty/patches2/100-remove_obsolete_config_h.patch    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/patches2/100-remove_obsolete_config_h.patch    2007-01-31 18:46:19.647064000 +0100
@@ -0,0 +1,10 @@
+--- sdio/include/linux/sdio/ctsystem_linux.old 2007-01-20 11:29:03.000000000 +0100
++++ sdio/include/linux/sdio/ctsystem_linux.h 2007-01-20 11:30:01.000000000 +0100
+@@ -45,7 +45,6 @@
+ #define SD_TRACK_REQ 1
+
+ /* LINUX support */
+-#include <linux/config.h>
+ #include <linux/module.h>
+ #include <linux/kernel.h>
+ #include <linux/init.h>
diff -uNr empty/empty/empty/patches2/110-pnp_dummy.patch packages/utils/sdio/patches2/110-pnp_dummy.patch
--- empty/empty/empty/patches2/110-pnp_dummy.patch    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/patches2/110-pnp_dummy.patch    2007-04-04 00:58:59.039315200 +0200
@@ -0,0 +1,31 @@
+--- src.orig/drivers/sdio/busdriver/sdio_bus_os.c       2007-01-31 18:51:03.000000000 +0100
++++ src/drivers/sdio/busdriver/sdio_bus_os.c    2007-01-31 18:58:24.000000000 +0100
+@@ -343,7 +343,7 @@
+
+ /****************************************************************************************/
+
+-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
++#if 0
+ #include <linux/pnp.h>
+
+ #if !defined(CONFIG_PNP)
+@@ -348,7 +348,7 @@
+ #include <linux/pnp.h>
+
+ #if !defined(CONFIG_PNP)
+-#error "CONFIG_PNP not defined"
++#warning "CONFIG_PNP not defined"
+ #endif
+
+ static ULONG InUseDevices = 0;
+@@ -741,8 +741,8 @@
+ EXPORT_SYMBOL(SDIO_BusAddOSDevice);
+ EXPORT_SYMBOL(SDIO_BusRemoveOSDevice);
+
+-#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+-    /* 2.4 */
++#elif 1
++
+ static int RegisterDriver(PSDFUNCTION pFunction)
+ {
+     return 0;
diff -uNr empty/empty/empty/patches2/120-sdio_memory_update_request_struct.patch packages/utils/sdio/patches2/120-sdio_memory_update_request_struct.patch
--- empty/empty/empty/patches2/120-sdio_memory_update_request_struct.patch    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/patches2/120-sdio_memory_update_request_struct.patch    2007-04-09 23:10:14.278016000 +0200
@@ -0,0 +1,25 @@
+--- src.orig/drivers/sdio/function/memory/sdio_memory_os.c.orig       2007-02-01 02:06:44.512798400 +0100
++++ src/drivers/sdio/function/memory/sdio_memory_os.c    2007-02-01 02:08:32.177612800 +010
+@@ -566,8 +566,8 @@
+     while ((pRequest = elv_next_request(pQueue)) != NULL) {
+          if (!blk_fs_request(pRequest)) {
+             /* not a command we care about */
+-            DBG_PRINT(SDDBG_TRACE, ("SDIO Memory Function: DiskRequest - unsupported command: flags 0x%X\n",
+-                                    (UINT)pRequest->flags));
++            DBG_PRINT(SDDBG_TRACE, ("SDIO Memory Function: DiskRequest - unsupported command: flags 0x%X\n",
++                                    (UINT)pRequest->cmd_flags));
+             end_request(pRequest, 0);
+             continue;
+         }
+@@ -743,8 +743,8 @@
+          DBG_PRINT(SDDBG_TRACE, ("SDIO Memory Function: DiskRequestDma : processing block request :0x%X\n",(UINT32)pRequest));
+         if (!blk_fs_request(pRequest)) {
+             /* not a command we care about */
+-            DBG_PRINT(SDDBG_TRACE, ("SDIO Memory Function: DiskRequestDma - unsupported command: flags 0x%X\n",
+-                                    (UINT)pRequest->flags));
++            DBG_PRINT(SDDBG_TRACE, ("SDIO Memory Function: DiskRequestDma - unsupported command: flags 0x%X\n",
++                                    (UINT)pRequest->cmd_flags));
+             end_request(pRequest, 0);
+                 /* reset */
+             outstandingReq = 1;
+
diff -uNr empty/empty/empty/patches2/130-sdio_memory_attend_max_blocksize.patch packages/utils/sdio/patches2/130-sdio_memory_attend_max_blocksize.patch
--- empty/empty/empty/patches2/130-sdio_memory_attend_max_blocksize.patch    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/patches2/130-sdio_memory_attend_max_blocksize.patch    2007-04-01 11:35:19.287500800 +0200
@@ -0,0 +1,13 @@
+diff -uNr sdio.orig/drivers/sdio/function/memory/sdio_memory.c sdio/drivers/sdio/function/memory/sdio_memory.c
+--- sdio.orig/drivers/sdio/function/memory/sdio_memory.c        2007-03-28 17:25:28.223070400 +0200
++++ sdio/drivers/sdio/function/memory/sdio_memory.c     2007-04-01 11:29:23.856416000 +0200
+@@ -576,6 +576,9 @@
+     /* MMC cards seem to want us to ignore the write block size and use the read block size,
+        SD cards have these equal to each other */
+     pInstance->BlockSize = pInstance->ReadBlockLength;
++       pInstance->BlockSize = (pInstance->BlockSize > SDDEVICE_GET_MAX_BLOCK_LEN(pDevice))?
++                        SDDEVICE_GET_MAX_BLOCK_LEN(pDevice) : pInstance->BlockSize;
++
+     pInstance->MaxBlocksPerTransfer = pDevice->pHcd->CardProperties.OperBlockCountLimit;
+     /* tell the device this is the block size we'll use for reads and writes */
+     status =  IssueDeviceRequest(pDevice, MMC_CMD_SET_BLOCK_LENGTH, pInstance->BlockSize,
diff -uNr empty/empty/empty/patches2/140-sdio_memory_capacity_bug.patch packages/utils/sdio/patches2/140-sdio_memory_capacity_bug.patch
--- empty/empty/empty/patches2/140-sdio_memory_capacity_bug.patch    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/patches2/140-sdio_memory_capacity_bug.patch    2007-04-14 19:16:06.606238400 +0200
@@ -0,0 +1,14 @@
+--- sdio.orig/drivers/sdio/function/memory/sdio_memory_os.c     2007-03-28 17:25:28.263128000 +0200
++++ sdio/drivers/sdio/function/memory/sdio_memory_os.c  2007-04-11 23:08:17.652344000 +0200
+@@ -385,9 +385,9 @@
+                             (INT)pInstance->Config.pGenDisk->driverfs_dev));
+ #endif
+
+-    set_capacity(pInstance->Config.pGenDisk, pInstance->Size/pInstance->FileSysBlockSize * 1024);
++    set_capacity(pInstance->Config.pGenDisk, (pInstance->Size * (1024 / 512)));
+     DBG_PRINT(SDDBG_TRACE, ("SDIO Memory Function: CreateDisk: size %d (Size %d, FileSysBlockSize %d)\n",
+-                            pInstance->Size/pInstance->FileSysBlockSize * 1024,
++                            (pInstance->Size * (1024 / 512)),
+                             (INT)pInstance->Size, (INT)pInstance->FileSysBlockSize));
+     pInstance->Config.pGenDisk->queue = pInstance->Config.pRequestQueue ;
+     /* is it read only ? */
diff -uNr empty/empty/empty/patches2/150-sdio_memory_debug.patch packages/utils/sdio/patches2/150-sdio_memory_debug.patch
--- empty/empty/empty/patches2/150-sdio_memory_debug.patch    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/patches2/150-sdio_memory_debug.patch    2007-04-12 17:16:31.522284800 +0200
@@ -0,0 +1,31 @@
+diff -uNr sdio.orig/drivers/sdio/function/memory/sdio_memory_os.c sdio/drivers/sdio/function/memory/sdio_memory_os.c
+--- sdio.orig/drivers/sdio/function/memory/sdio_memory_os.c     2007-03-28 17:25:28.263128000 +0200
++++ sdio/drivers/sdio/function/memory/sdio_memory_os.c  2007-03-29 21:09:29.927684800 +0200
+@@ -574,6 +574,26 @@
+         pInstance = (PSDIO_MEMORY_INSTANCE)pRequest->rq_disk->private_data;
+         /* we don't need the queue spinlock while processing the head of the queue */
+         spin_unlock_irq(&pInstance->Config.RequestLock);
++            #ifdef DEBUG         
++                DBG_PRINT(SDDBG_TRACE,("SDIO pRequest->buffer = %p\n",(PUCHAR)pRequest->buffer));
++            #ifdef SDIO_MEM_CHKBUFFERINIT
++                if (DBG_GET_DEBUG_LEVEL() >= (SDDBG_TRACE)) {
++                    UINT i; 
++                    for (i=0; i < pRequest->current_nr_sectors * pInstance->FileSysBlockSize; i++)
++                        if (pRequest->buffer[i] != 0x00) break;
++                    if (pRequest->buffer[i] != 0x00)        
++                        DBG_PRINT(SDDBG_TRACE ,("SDIO buffer not initialised with 0: pRequest->buffer[%u] = %02X\n",i,pRequest->buffer[i]))
++                    else
++                        DBG_PRINT(SDDBG_TRACE + 1,("SDIO buffer perfectly initialised with 0: pRequest->buffer[%u] = %02X\n",i,pRequest->buffer[i]));                        
++                }
++            #endif
++               if (DBG_GET_DEBUG_LEVEL() >= (SDDBG_TRACE) + 2) {
++                               SDLIB_PrintBuffer( (PUCHAR)pRequest->buffer,
++                               0x200,//pRequest->current_nr_sectors *  pInstance->FileSysBlockSize,
++                               "SDIO Memory Function: BUFFER (before writing into it...)");
++               }
++                //memset((PUCHAR)pRequest->buffer,0x99,pRequest->current_nr_sectors *  pInstance->FileSysBlockSize);
++            #endif
+         if (SDIO_SUCCESS(MemoryTransfer(pInstance,
+                                         pRequest->sector, pRequest->current_nr_sectors,
+                                         pRequest->buffer, rq_data_dir(pRequest)))) {
+
diff -uNr empty/empty/empty/src/Makefile packages/utils/sdio/src/Makefile
--- empty/empty/empty/src/Makefile    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/src/Makefile    2007-01-31 17:47:31.173368000 +0100
@@ -0,0 +1,5 @@
+obj-m      += drivers/sdio/
+
+ifeq ($(MAKING_MODULES),1)
+-include $(TOPDIR)/Rules.make
+endif
diff -uNr empty/empty/empty/src/drivers/sdio/Makefile packages/utils/sdio/src/drivers/sdio/Makefile
--- empty/empty/empty/src/drivers/sdio/Makefile    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/src/drivers/sdio/Makefile    2007-01-31 08:28:43.274913600 +0100
@@ -0,0 +1,2 @@
+#Makefile for SDIO stack
+obj-m      += busdriver/  function/  hcd/  lib/
diff -uNr empty/empty/empty/src/drivers/sdio/hcd/Makefile packages/utils/sdio/src/drivers/sdio/hcd/Makefile
--- empty/empty/empty/src/drivers/sdio/hcd/Makefile    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/src/drivers/sdio/hcd/Makefile    2007-01-31 14:06:52.952110400 +0100
@@ -0,0 +1,2 @@
+# SDIO stack host controller Makefile
+obj-m        += gpio/
diff -uNr empty/empty/empty/src/drivers/sdio/hcd/gpio/Makefile packages/utils/sdio/src/drivers/sdio/hcd/gpio/Makefile
--- empty/empty/empty/src/drivers/sdio/hcd/gpio/Makefile    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/src/drivers/sdio/hcd/gpio/Makefile    2007-02-18 00:13:56.764246400 +0100
@@ -0,0 +1,20 @@
+# $Id$
+#
+# Makefile for switch driver
+#
+# Copyright (C) 2005 Felix Fietkau <nbd@openwrt.org>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version
+# 2 of the License, or (at your option) any later version.
+#
+
+obj-m    := sdio_gpio.o
+obj-m    += mmc_test.o
+
+#ifeq ($(MAKING_MODULES),1)
+#export-objs := switch-core.o
+
+#-include $(TOPDIR)/Rules.make
+#endif
diff -uNr empty/empty/empty/src/drivers/sdio/hcd/gpio/mmc_test.c packages/utils/sdio/src/drivers/sdio/hcd/gpio/mmc_test.c
--- empty/empty/empty/src/drivers/sdio/hcd/gpio/mmc_test.c    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/src/drivers/sdio/hcd/gpio/mmc_test.c    2007-03-25 12:08:15.846944000 +0200
@@ -0,0 +1,767 @@
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/kernel.h>
+
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+//#include <linux/fs.h>
+//#include <linux/blkpg.h>
+//#include <linux/hdreg.h>
+//#include <linux/major.h>
+//#include <asm/uaccess.h>
+#include <asm/io.h>
+
+//#define DEVICE_NAME "mmc"
+//#define DEVICE_NR(device) (MINOR(device))
+//#define DEVICE_ON(device)
+//#define DEVICE_OFF(device)
+//#define MAJOR_NR 121
+
+
+
+#define SPI_DELAY_FACTOR 0
+
+#if (SPI_DELAY_FACTOR != 0)
+    #define SPI_DELAY(__TIME) udelay(__TIME*SPI_DELAY_FACTOR)
+    #define SPI_DELAY(__TIME) mdelay(__TIME*SPI_DELAY_FACTOR)
+#else
+    #define SPI_DELAY(__TIME)
+#endif
+
+
+
+
+
+#if 0// LINUX 2.4
+#include <linux/blk.h>
+#endif
+#if 1 //LINUX 2.6
+//#include <linux/spinlock.h>
+#endif
+
+#if 1
+#include "ar531x.h"
+#endif
+
+MODULE_AUTHOR("Madsuk/Rohde");
+MODULE_DESCRIPTION("Driver MMC/SD-Cards");
+//MODULE_SUPPORTED_DEVICE("WRT54G");
+MODULE_LICENSE("GPL");
+
+
+#define SD_DI (1 << (CONFIG_KMOD_MMC_GPIO_DI))
+#define SD_DO  (1 << (CONFIG_KMOD_MMC_GPIO_DO))
+#define SD_CLK (1 << (CONFIG_KMOD_MMC_GPIO_CLK))
+#define SD_CS  (1 << (CONFIG_KMOD_MMC_GPIO_CS))
+
+
+/* we have only one device */
+static int hd_sizes[1<<6];
+static int hd_blocksizes[1<<6];
+static int hd_hardsectsizes[1<<6];
+static int hd_maxsect[1<<6];
+//static struct hd_struct hd[1<<6];
+
+static struct timer_list mmc_timer;
+static int mmc_media_detect = 0;
+static int mmc_media_changed = 1;
+
+typedef unsigned int uint32;
+
+static unsigned int port_state = 0x00;
+
+#if (0)
+//LINUX_KARCH //BROADCOM
+
+static volatile uint32 *gpioaddr_input = (uint32 *)0xb8000060;
+static volatile uint32 *gpioaddr_output = (uint32 *)0xb8000064;
+static volatile uint32 *gpioaddr_enable = (uint32 *)0xb8000068;
+static volatile uint32 *gpioaddr_control = (uint32 *)0xb800006c;
+#define GPIO_DIR_IN 1
+
+#endif
+
+#if (1)    //ATHEROS
+
+static volatile uint32 *gpioaddr_input = (uint32 *)  KSEG1ADDR(AR5315_GPIO_DI);
+static volatile uint32 *gpioaddr_output = (uint32 *) KSEG1ADDR(AR5315_GPIO_DO);
+static volatile uint32 *gpioaddr_enable = (uint32 *) KSEG1ADDR(AR5315_GPIO_CR);
+#define GPIO_DIR_IN 0
+
+#endif
+
+
+
+static void mmc_spi_cs_low(void)
+{
+  port_state &= ~(SD_CS);
+  *gpioaddr_output = port_state;
+  SPI_DELAY(1);
+}
+
+static void mmc_spi_cs_high(void)
+{
+  port_state |= SD_CS;
+  *gpioaddr_output = port_state;
+  SPI_DELAY(1);
+}
+
+static unsigned char mmc_spi_io(unsigned char data_out)
+{
+  int i;
+  unsigned char result = 0, tmp_data = 0;
+  
+  for(i=0; i<8; i++) {
+    if(data_out & (0x01 << (7-i)))
+      port_state |= SD_DI;
+    else
+      port_state &= ~SD_DI;
+    
+    *gpioaddr_output = port_state;
+    SPI_DELAY(1);
+    
+    port_state |= SD_CLK;
+    *gpioaddr_output = port_state;
+    SPI_DELAY(1);
+    
+    tmp_data = *gpioaddr_input;
+    
+    port_state &= ~SD_CLK;
+    *gpioaddr_output = port_state;
+    SPI_DELAY(1);
+    
+    result <<= 1;
+    
+    if(tmp_data & SD_DO)
+      result |= 1;
+  }
+  //if (result != 0xff ||  data_out != 0xff ) 
+    printk("mmc WRITE:%X READ:%X \n",data_out,result);
+    
+  return(result);
+}
+
+static int mmc_write_block(unsigned int dest_addr, unsigned char *data)
+{
+    unsigned int address;
+    unsigned char r = 0;
+    unsigned char ab0, ab1, ab2, ab3;
+    int i;
+
+    address = dest_addr;
+
+    ab3 = 0xff & (address >> 24);
+    ab2 = 0xff & (address >> 16);
+    ab1 = 0xff & (address >> 8);
+    ab0 = 0xff & address;
+    mmc_spi_cs_low();
+    for (i = 0; i < 4; i++) mmc_spi_io(0xff);
+    mmc_spi_io(0x58);
+    mmc_spi_io(ab3); /* msb */
+    mmc_spi_io(ab2);
+    mmc_spi_io(ab1);
+    mmc_spi_io(ab0); /* lsb */
+    mmc_spi_io(0xff);
+    for (i = 0; i < 8; i++)
+    {
+        r = mmc_spi_io(0xff);
+        if (r == 0x00) break;
+    }
+    if (r != 0x00)
+    {
+        mmc_spi_cs_high();
+        mmc_spi_io(0xff);
+        return(1);
+    }
+
+    mmc_spi_io(0xfe);
+    for (i = 0; i < 512; i++) mmc_spi_io(data[i]);
+    for (i = 0; i < 2; i++) mmc_spi_io(0xff);
+
+    for (i = 0; i < 1000000; i++)
+    {
+        r = mmc_spi_io(0xff);
+        if (r == 0xff) break;
+    }
+    if (r != 0xff)
+    {
+        mmc_spi_cs_high();
+        mmc_spi_io(0xff);
+        return(3);
+    }
+    mmc_spi_cs_high();
+    mmc_spi_io(0xff);
+    return(0);
+}
+
+static int mmc_read_block(unsigned char *data, unsigned int src_addr)
+{
+    unsigned int address;
+    unsigned char r = 0;
+    unsigned char ab0, ab1, ab2, ab3;
+    int i;
+
+    address = src_addr;
+
+    ab3 = 0xff & (address >> 24);
+    ab2 = 0xff & (address >> 16);
+    ab1 = 0xff & (address >> 8);
+    ab0 = 0xff & address;
+
+    mmc_spi_cs_low();
+    for (i = 0; i < 4; i++) mmc_spi_io(0xff);
+    mmc_spi_io(0x51);
+    mmc_spi_io(ab3); /* msb */
+    mmc_spi_io(ab2);
+    mmc_spi_io(ab1);
+    mmc_spi_io(ab0); /* lsb */
+
+    mmc_spi_io(0xff);
+    for (i = 0; i < 8; i++)
+    {
+        r = mmc_spi_io(0xff);
+        if (r == 0x00) break;
+    }
+    if (r != 0x00)
+    {
+        mmc_spi_cs_high();
+        mmc_spi_io(0xff);
+        return(1);
+    }
+    for (i = 0; i < 100000; i++)
+    {
+        r = mmc_spi_io(0xff);
+        if (r == 0xfe) break;
+    }
+    if (r != 0xfe)
+    {
+        mmc_spi_cs_high();
+        mmc_spi_io(0xff);
+        return(2);
+    }
+    for (i = 0; i < 512; i++)
+    {
+        r = mmc_spi_io(0xff);
+        data[i] = r;
+    }
+    for (i = 0; i < 2; i++)
+    {
+        r = mmc_spi_io(0xff);
+    }
+    mmc_spi_cs_high();
+    mmc_spi_io(0xff);
+
+    return(0);
+}
+#if (0)
+static void mmc_request(request_queue_t *q)
+{
+    unsigned int mmc_address;
+    unsigned char *buffer_address;
+    int nr_sectors;
+    int i;
+    int cmd;
+    int rc, code;
+    
+    (void)q;
+    while (1)
+    {
+        code = 1; // Default is success
+        INIT_REQUEST;
+        mmc_address = (CURRENT->sector + hd[MINOR(CURRENT->rq_dev)].start_sect) * hd_hardsectsizes[0];
+        buffer_address = CURRENT->buffer;
+        nr_sectors = CURRENT->current_nr_sectors;
+        cmd = CURRENT->cmd;
+        if (((CURRENT->sector + CURRENT->current_nr_sectors + hd[MINOR(CURRENT->rq_dev)].start_sect) > hd[0].nr_sects) || (mmc_media_detect == 0))
+        {
+            code = 0;
+        }
+        else if (cmd == READ)
+        {
+            spin_unlock_irq(&io_request_lock);
+            for (i = 0; i < nr_sectors; i++)
+            {
+                rc = mmc_read_block(buffer_address, mmc_address);
+                if (rc != 0)
+                {
+                    printk("mmc: error in mmc_read_block (%d)\n", rc);
+                    code = 0;
+                    break;
+                }
+                else
+                {
+                    mmc_address += hd_hardsectsizes[0];
+                    buffer_address += hd_hardsectsizes[0];
+                }
+            }
+            spin_lock_irq(&io_request_lock);
+        }
+        else if (cmd == WRITE)
+        {
+            spin_unlock_irq(&io_request_lock);
+            for (i = 0; i < nr_sectors; i++)
+            {
+                rc = mmc_write_block(mmc_address, buffer_address);
+                if (rc != 0)
+                {
+                    printk("mmc: error in mmc_write_block (%d)\n", rc);
+                    code = 0;
+                    break;
+                }
+                else
+                {
+                    mmc_address +=     hd_hardsectsizes[0];
+                    buffer_address += hd_hardsectsizes[0];
+                }
+            }
+            spin_lock_irq(&io_request_lock);
+        }
+        else
+        {
+            code = 0;
+        }
+        end_request(code);
+    }
+}
+#endif
+
+#if (0)
+static int mmc_open(struct inode *inode, struct file *filp)
+{
+    int device;
+    (void)filp;
+    
+    if (mmc_media_detect == 0) return -ENODEV;
+
+#if defined(MODULE)
+    //MOD_INC_USE_COUNT;
+#endif
+    return 0;
+}
+
+
+static int mmc_release(struct inode *inode, struct file *filp)
+{
+    (void)filp;
+    fsync_dev(inode->i_rdev);
+        invalidate_buffers(inode->i_rdev);
+
+#if defined(MODULE)
+//    MOD_DEC_USE_COUNT;
+#endif
+    return 0;
+}
+
+extern struct gendisk hd_gendisk;
+static int mmc_revalidate(kdev_t dev)
+{
+    int target, max_p, start, i;
+    if (mmc_media_detect == 0) return -ENODEV;
+    
+    target = DEVICE_NR(dev);
+
+    max_p = hd_gendisk.max_p;
+    start = target << 6;
+    for (i = max_p - 1; i >= 0; i--) {
+        int minor = start + i;
+        invalidate_device(MKDEV(MAJOR_NR, minor), 1);
+        hd_gendisk.part[minor].start_sect = 0;
+        hd_gendisk.part[minor].nr_sects = 0;
+    }
+    
+    grok_partitions(&hd_gendisk, target, 1 << 6,
+            hd_sizes[0] * 2);
+
+    return 0;
+}
+
+static int mmc_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    if (!inode || !inode->i_rdev)
+        return -EINVAL;
+
+    switch(cmd) {
+    case BLKGETSIZE:
+        return put_user(hd[MINOR(inode->i_rdev)].nr_sects, (unsigned long *)arg);
+    case BLKGETSIZE64:
+        return put_user((u64)hd[MINOR(inode->i_rdev)].
+                nr_sects, (u64 *) arg);
+    case BLKRRPART:
+        if (!capable(CAP_SYS_ADMIN))
+            return -EACCES;
+            
+        return mmc_revalidate(inode->i_rdev);
+    case HDIO_GETGEO:
+    {
+        struct hd_geometry *loc, g;
+        loc = (struct hd_geometry *) arg;
+        if (!loc)
+            return -EINVAL;
+        g.heads = 4;
+        g.sectors = 16;
+        g.cylinders = hd[0].nr_sects / (4 * 16);
+        g.start = hd[MINOR(inode->i_rdev)].start_sect;
+        return copy_to_user(loc, &g, sizeof(g)) ? -EFAULT : 0;
+    }
+    default:
+        return blk_ioctl(inode->i_rdev, cmd, arg);
+    }
+}
+
+#endif
+
+
+static int mmc_card_init(void)
+{
+    unsigned char r = 0;
+    short i, j;
+    unsigned long flags;
+
+//    save_flags(flags);
+//    cli();
+
+        printk("mmc Card init (DI:%X DO:%X CLK:%X CS:%X)\n",
+                                    CONFIG_KMOD_MMC_GPIO_DI,CONFIG_KMOD_MMC_GPIO_DO,
+                                    CONFIG_KMOD_MMC_GPIO_CLK,CONFIG_KMOD_MMC_GPIO_CS);
+
+    mmc_spi_cs_high();
+    for (i = 0; i < 80*8; i++) {
+        port_state |= SD_CLK;
+        *gpioaddr_output = port_state;
+        SPI_DELAY(1);        
+        port_state &= ~SD_CLK;
+        *gpioaddr_output = port_state;
+        SPI_DELAY(1);
+    }
+    
+    mmc_spi_cs_low();
+    
+    for (i = 0; i < 16; i++) mmc_spi_io(0xff);
+    
+    mmc_spi_io(0x40);
+    for (i = 0; i < 4; i++) mmc_spi_io(0x00);
+    mmc_spi_io(0x95);
+    for (i = 0; i < 8; i++)
+    {
+        r = mmc_spi_io(0xff);
+        if (r == 0x01) break;
+    }
+    mmc_spi_cs_high();
+    mmc_spi_io(0xff);
+    if (r != 0x01)
+    {   
+        //restore_flags(flags);
+        return(1);
+    }
+
+        printk("mmc Card init *1*\n");
+    for (j = 0; j < 10000; j++)
+    {
+        mmc_spi_cs_low();
+
+        mmc_spi_io(0x41);
+        for (i = 0; i < 4; i++) mmc_spi_io(0x00);
+        mmc_spi_io(0xff);
+        for (i = 0; i < 8; i++)
+        {
+            r = mmc_spi_io(0xff);
+            if (r == 0x00) break;
+        }
+        mmc_spi_cs_high();
+        mmc_spi_io(0xff);
+        if (r == 0x00)
+        {
+            //restore_flags(flags);
+            printk("mmc Card init *2*\n");
+            return(0);
+        }
+    }
+//    restore_flags(flags);
+
+    return(2);
+}
+
+static int mmc_card_config(void)
+{
+    unsigned char r = 0;
+    short i;
+    unsigned char csd[32];
+    unsigned int c_size;
+    unsigned int c_size_mult;
+    unsigned int mult;
+    unsigned int read_bl_len;
+    unsigned int blocknr = 0;
+    unsigned int block_len = 0;
+    unsigned int size = 0;
+
+    mmc_spi_cs_low();
+    for (i = 0; i < 4; i++) mmc_spi_io(0xff);
+    mmc_spi_io(0x49);
+    for (i = 0; i < 4; i++) mmc_spi_io(0x00);
+    mmc_spi_io(0xff);
+    for (i = 0; i < 8; i++)
+    {
+        r = mmc_spi_io(0xff);
+        if (r == 0x00) break;
+    }
+    if (r != 0x00)
+    {
+        mmc_spi_cs_high();
+        mmc_spi_io(0xff);
+        return(1);
+    }
+    for (i = 0; i < 8; i++)
+    {
+        r = mmc_spi_io(0xff);
+        if (r == 0xfe) break;
+    }
+    if (r != 0xfe)
+    {
+        mmc_spi_cs_high();
+        mmc_spi_io(0xff);
+        return(2);
+    }
+    for (i = 0; i < 16; i++)
+    {
+        r = mmc_spi_io(0xff);
+        csd[i] = r;
+    }
+    for (i = 0; i < 2; i++)
+    {
+        r = mmc_spi_io(0xff);
+    }
+    mmc_spi_cs_high();
+    mmc_spi_io(0xff);
+    if (r == 0x00) return(3);
+
+    c_size = csd[8] + csd[7] * 256 + (csd[6] & 0x03) * 256 * 256;
+    c_size >>= 6;
+    c_size_mult = csd[10] + (csd[9] & 0x03) * 256;
+    c_size_mult >>= 7;
+    read_bl_len = csd[5] & 0x0f;
+    mult = 1;
+    mult <<= c_size_mult + 2;
+    blocknr = (c_size + 1) * mult;
+    block_len = 1;
+    block_len <<= read_bl_len;
+    size = block_len * blocknr;
+    size >>= 10;
+    
+#if 0
+
+    for(i=0; i<(1<<6); i++) {
+      hd_blocksizes[i] = 1024;
+      hd_hardsectsizes[i] = block_len;
+      hd_maxsect[i] = 256;
+    }
+    hd_sizes[0] = size;
+    hd[0].nr_sects = blocknr;
+
+#endif
+
+    printk("Size = %d, hardsectsize = %d, sectors = %d\n",
+           size, block_len, blocknr);
+
+    return 0;
+}
+
+static int mmc_hardware_init(void)
+{
+  unsigned char gpio_outen;
+  
+  // Set inputs/outputs here
+  printk("mmc Hardware init\n");
+  gpio_outen = *gpioaddr_enable;
+  #if ((GPIO_DIR_IN) == 0)
+    gpio_outen = (gpio_outen | SD_DI | SD_CLK | SD_CS) & ~SD_DO;
+  #else
+    gpio_outen = (gpio_outen & ~SD_DI & ~SD_CLK & ~SD_CS) | SD_DO;
+  #endif
+  
+  *gpioaddr_enable = gpio_outen;
+  
+  //port_state = *gpioaddr_input;
+  port_state = *gpioaddr_output;
+  
+  // Clock low
+  //port_state &= ~(SD_CLK | SD_DI | SD_CS);
+  port_state &= ~(SD_CLK);
+  port_state |=(SD_DI | SD_CS);
+  *gpioaddr_output = port_state;
+
+  return 0;
+}
+
+#if 0
+static int mmc_check_media_change(kdev_t dev)
+{
+    (void)dev;
+    if (mmc_media_changed == 1)
+    {
+        mmc_media_changed = 0;
+        return 1;
+    }
+    else return 0;
+}
+
+
+
+static struct block_device_operations mmc_bdops = 
+{
+    open: mmc_open,
+    release: mmc_release,
+    ioctl: mmc_ioctl,
+#if 0
+    check_media_change: mmc_check_media_change,
+    revalidate: mmc_revalidate,
+#endif
+};
+
+
+static struct gendisk hd_gendisk = {
+    major:        MAJOR_NR,
+    major_name:    DEVICE_NAME,
+    minor_shift:    6,
+    max_p:        1 << 6,
+    part:        hd,
+    sizes:        hd_sizes,
+    fops:        &mmc_bdops,
+};
+#endif
+
+static int mmc_init(void)
+{
+    int rc;
+
+    rc = mmc_hardware_init(); 
+
+    if ( rc != 0)
+    {
+        printk("mmc: error in mmc_hardware_init (%d)\n", rc);
+        return -1;
+    }
+
+    rc = mmc_card_init(); 
+    if ( rc != 0)
+    {
+        // Give it an extra shot
+        rc = mmc_card_init(); 
+        if ( rc != 0)
+        {
+            printk("mmc: error in mmc_card_init (%d)\n", rc);
+            return -1;
+        }
+    }
+
+    memset(hd_sizes, 0, sizeof(hd_sizes));
+    rc = mmc_card_config(); 
+    if ( rc != 0)
+    {
+        printk("mmc: error in mmc_card_config (%d)\n", rc);
+        return -1;
+    }
+    
+#if 0
+    blk_size[MAJOR_NR] = hd_sizes;
+
+    memset(hd, 0, sizeof(hd));
+    hd[0].nr_sects = hd_sizes[0]*2;
+
+    blksize_size[MAJOR_NR] = hd_blocksizes;
+    hardsect_size[MAJOR_NR] = hd_hardsectsizes;
+    max_sectors[MAJOR_NR] = hd_maxsect;
+
+    hd_gendisk.nr_real = 1;
+
+    register_disk(&hd_gendisk, MKDEV(MAJOR_NR,0), 1<<6,
+              &mmc_bdops, hd_sizes[0]*2);
+#endif
+    return 0;
+}
+
+static void mmc_exit(void)
+{
+#if 0
+    blk_size[MAJOR_NR] = NULL;
+    blksize_size[MAJOR_NR] = NULL;
+    hardsect_size[MAJOR_NR] = NULL;
+    max_sectors[MAJOR_NR] = NULL;
+    hd[0].nr_sects = 0;
+#endif
+}
+
+static void mmc_check_media(void)
+{
+    int old_state;
+    int rc;
+    
+    old_state = mmc_media_detect; 
+
+    // TODO: Add card detection here
+    mmc_media_detect = 1;
+    if (old_state != mmc_media_detect) 
+    {
+        mmc_media_changed = 1;
+        if (mmc_media_detect == 1)
+        {
+            rc = mmc_init();
+            if (rc != 0) printk("mmc: error in mmc_init (%d)\n", rc);
+        }
+        else 
+        {
+            mmc_exit();
+        }
+    }
+
+    /* del_timer(&mmc_timer);
+    mmc_timer.expires = jiffies + 10*HZ;
+    add_timer(&mmc_timer); */
+}
+
+static int __init mmc_driver_init(void)
+{
+    int rc;
+#if (0)
+    rc = devfs_register_blkdev(MAJOR_NR, DEVICE_NAME, &mmc_bdops);
+    if (rc < 0)
+    {
+        printk(KERN_WARNING "mmc: can't get major %d\n", MAJOR_NR);
+        return rc;
+    }
+
+    blk_init_queue(BLK_DEFAULT_QUEUE(MAJOR_NR), mmc_request);
+
+    read_ahead[MAJOR_NR] = 8;
+    add_gendisk(&hd_gendisk);
+    
+#endif    
+
+    mmc_check_media();
+
+    /*init_timer(&mmc_timer);
+    mmc_timer.expires = jiffies + HZ;
+    mmc_timer.function = (void *)mmc_check_media;
+    add_timer(&mmc_timer);*/
+
+    return 0;
+}
+
+static void __exit mmc_driver_exit(void)
+{
+#if (0)
+    int i;
+    del_timer(&mmc_timer);
+
+    for (i = 0; i < (1 << 6); i++)
+        fsync_dev(MKDEV(MAJOR_NR, i));
+
+    blk_cleanup_queue(BLK_DEFAULT_QUEUE(MAJOR_NR));
+    del_gendisk(&hd_gendisk);
+    devfs_unregister_blkdev(MAJOR_NR, DEVICE_NAME);
+#endif
+    mmc_exit();
+}
+
+module_init(mmc_driver_init);
+module_exit(mmc_driver_exit);
diff -uNr empty/empty/empty/src/drivers/sdio/hcd/gpio/sdio_gpio.c packages/utils/sdio/src/drivers/sdio/hcd/gpio/sdio_gpio.c
--- empty/empty/empty/src/drivers/sdio/hcd/gpio/sdio_gpio.c    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/src/drivers/sdio/hcd/gpio/sdio_gpio.c    2007-04-24 23:38:17.559027200 +0200
@@ -0,0 +1,610 @@
+//SDIO-HCD Implementation for GPIO Bitbanging SPI
+//Licence: GPL
+//by olg
+//used some code from Madsuk/Rohde, Seung Yi and Paul Lever 
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ */
+
+#include "sdio_gpio.h"
+
+int debuglevel = 7;
+module_param(debuglevel, int, 0644);
+MODULE_PARM_DESC(debuglevel, "debuglevel 0-12, controls debug prints");
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION(DESCRIPTION);
+MODULE_AUTHOR("OLG");
+
+module_init(sdio_hcd_init);
+module_exit(sdio_hcd_cleanup);
+
+static SDHCD_DRIVER_CONTEXT HcdContext = {
+    .pDescription = DESCRIPTION,
+    .Hcd.pName = "sdio_gpio",
+    .Hcd.Version = CT_SDIO_STACK_VERSION_CODE,
+    .Hcd.SlotNumber = 0,
+    .Hcd.Attributes = SDHCD_ATTRIB_BUS_SPI | SDHCD_ATTRIB_NO_SPI_CRC | SDHCD_ATTRIB_SLOT_POLLING |
+                    SDHCD_ATTRIB_MMC_HIGH_SPEED    | SDHCD_ATTRIB_AUTO_CMD12,
+    .Hcd.MaxBytesPerBlock = 512,
+    .Hcd.MaxBlocksPerTrans = 2048,
+    .Hcd.MaxSlotCurrent = 500,    /* 1/2 amp */
+    .Hcd.SlotVoltageCaps = SLOT_POWER_3_3V,    /* 3.3V */
+    .Hcd.SlotVoltagePreferred = SLOT_POWER_3_3V,    /* 3.3V */
+    .Hcd.MaxClockRate = CLKRATE,
+    .Hcd.pContext = &HcdContext,
+    .Hcd.pRequest = HcdRequest,
+    .Hcd.pConfigure = HcdConfig,
+    .Hcd.pDmaDescription = NULL
+    //.Device.HcdDevice=NULL;
+    //.Device.HcdDriver=NULL;
+    //.Device.HcdDevice.name = "sdio_gpio_hcd",
+    //.Device.HcdDriver.name = "sdio_gpio_hcd",
+    //.Device.HcdDriver.probe  = NULL,
+    //.Device.HcdDriver.remove = NULL,
+};
+
+
+/*
+ * module init
+*/
+static int __init sdio_hcd_init(void)
+{
+    SDIO_STATUS status;
+    DBG_PRINT(DBG_VERBOSE,
+              ("SDIO GPIO loading.. (DI:%X DO:%X CLK:%X CS:%X)\n",
+               CONFIG_KMOD_MMC_GPIO_DI, CONFIG_KMOD_MMC_GPIO_DO,
+               CONFIG_KMOD_MMC_GPIO_CLK, CONFIG_KMOD_MMC_GPIO_CS));
+
+    spi_gpio_init();
+
+    HcdContext.Hcd.pModule = THIS_MODULE;
+
+    if (!SDIO_SUCCESS
+        ((status = SDIO_RegisterHostController(&HcdContext.Hcd)))) {
+        DBG_PRINT(SDDBG_ERROR,
+                  ("SDIO HCD - failed to register with host, status =%d\n",
+                   status));
+    } //else
+        //SDIO_HandleHcdEvent(&HcdContext.Hcd, EVENT_HCD_ATTACH);
+
+    return status;
+}
+
+/*
+ * module cleanup
+*/
+static void __exit sdio_hcd_cleanup(void)
+{
+    SDIO_STATUS status;
+    spi_gpio_cleanup();
+
+    REL_PRINT(DBG_VERBOSE, ("+SDIO GPIO Local HCD: unloaded\n"));
+    if (!SDIO_SUCCESS
+        ((status = SDIO_UnregisterHostController(&HcdContext.Hcd)))) {
+        DBG_PRINT(SDDBG_ERROR,
+                  ("SDIO HCD - failed to unregister with host, status =%d\n",
+                   status));
+    }
+}
+
+static unsigned char spi_io_ff(void)
+{
+    UINT8 result = 0, i;
+
+    spi_out_hi();
+    spi_writeout();
+
+    for (i = 0; i < 8; i++) {
+
+        spi_clk_hi();
+        spi_writeout();
+        SPI_DELAY(2);
+        
+        result <<= 1;
+        if (spi_read())
+            result |= 1;
+            
+        spi_clk_lo();
+        spi_writeout();
+        SPI_DELAY(2);
+            
+    }
+    
+    //if (result != 0xff)
+        DBG_PRINT(DBG_VERBOSE_SPI_DATA,
+                  ("SDIO GPIO spi_io() WROTE 0xFF , READ:0x%02X , CS:%i) \n",
+                   result,spi_cs_state()));
+    return (result);
+}
+
+
+
+static unsigned char spi_io_wr(unsigned char data_out)
+{
+    UINT8 result = 0,  i;
+
+    for (i = 0; i < 8; i++) {
+        if (data_out & (0x01 << (7 - i)))
+                spi_out_hi();
+            else
+                spi_out_lo();
+
+        spi_writeout();
+        SPI_DELAY(1);
+
+        spi_clk_hi();
+        spi_writeout();
+        SPI_DELAY(1);
+        
+        result <<= 1;
+        if (spi_read())
+            result |= 1;
+
+        spi_clk_lo();
+        spi_writeout();
+        SPI_DELAY(1);
+            
+    }
+    
+//    if (result != 0xff)
+        DBG_PRINT(DBG_VERBOSE_SPI_DATA,
+              ("SDIO GPIO spi_io() WROTE 0x%02X , READ:0x%02X, CS:%i) \n",
+               data_out, result,spi_cs_state()));
+    return (result);
+}
+
+
+static void force_deferred_handler(void *context)
+{    
+    PSDHCD_DRIVER_CONTEXT pHcdContext = (PSDHCD_DRIVER_CONTEXT)context;
+    //PSDHCD_DRIVER_CONTEXT pHcdContext = &HcdContext;
+    #ifdef DEBUG
+    PSDREQUEST pReq;
+    DBG_ASSERT(pHcdContext != NULL);
+    DBG_ASSERT(&pHcdContext->Hcd != NULL);
+    pReq = GET_CURRENT_REQUEST(&pHcdContext->Hcd);
+    DBG_ASSERT(pReq != NULL);
+    #endif
+
+    SDIO_HandleHcdEvent(&pHcdContext->Hcd, EVENT_HCD_TRANSFER_DONE);
+        
+    #ifdef DEBUG
+    if (pReq->Command == 0x0D) 
+        debuglevel -= 3;
+    DBG_PRINT(DBG_VERBOSE,
+              ("SDIO HCD - Handler    SDREQ_FLAGS_FORCE_DEFERRED_COMPLETE(&pHcdContext->Hcd=%p)\n",&pHcdContext->Hcd ));
+    if (pReq->Command == 0x0D) 
+        debuglevel += 3;          
+    #endif
+    
+}
+
+static DECLARE_WORK(deferred_complete, force_deferred_handler, &HcdContext);
+
+
+SDIO_STATUS HcdRequest(PSDHCD pHcd)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    //PSDHCD_DRIVER_CONTEXT pHct = (PSDHCD_DRIVER_CONTEXT)pHcd->pContext;
+    UINT16 i;
+    PSDREQUEST pReq;
+    UINT8 r;
+    #ifdef SDIO_HCD_CHECK_IOT_PATTERN 
+    UINT32 iot;
+    #endif
+    #ifdef DEBUG
+    UCHAR errorcnt;
+    #endif
+    
+    pReq = GET_CURRENT_REQUEST(pHcd);
+    DBG_ASSERT(pReq != NULL);
+    DBG_ASSERT(IS_HCD_BUS_MODE_SPI(pHcd));
+#ifdef DEBUG    
+//    if (pReq->Argument == 0xF800000) 
+//        debuglevel=DBG_VERBOSE_SPI_DATA;
+//    else
+//        debuglevel=DBG_ERROR;
+
+    if (pReq->Command == 0x0D) 
+        debuglevel -= 3;
+#endif
+
+
+//    if (pReq->Command == CMD0) {
+//        for (i = 0; i < 16; i++)  spi_io(0xff);
+//    }
+
+    refresh_gpio_state();
+    spi_cs_lo();
+    for (i = 0; i < 4; i++) spi_io(0xff); //wait ???
+
+    //COMMAND
+    spi_io(0x40 | pReq->Command);
+
+    //ARGUMENT
+    //for (i = 4; i > 0; i--) {
+    //    spi_io(((pReq->Argument) >> ((i-1) * 8)) & 0xff);
+    //}
+    spi_io(((pReq->Argument) >> 24) & 0xff);
+    spi_io(((pReq->Argument) >> 16) & 0xff);
+    spi_io(((pReq->Argument) >> 8) & 0xff);
+    spi_io((pReq->Argument) & 0xff);
+        
+    //CRC   
+    if (pReq->Command == CMD0) {
+        /* this command must always have a CRC */
+        spi_io(0x95);
+    } else
+        spi_io(0xff);
+
+    spi_io(0xff); // 1 byte delay
+    
+    //RESPONSE    
+    if (GET_SDREQ_RESP_TYPE(pReq->Flags) == SDREQ_FLAGS_NO_RESP)
+        goto exit;
+    
+    r=spi_io(0xff);
+    
+    // wait for first non-0xff byte and take it as response
+    for (i = 0; i < SDIO_SPI_NCR; i++) {
+        if (!(r & 0x80))
+            break;
+        r = spi_io(0xff);
+    }
+
+    pReq->Response[0] = r;
+
+    if (r == 0xff) {
+        status = SDIO_STATUS_BUS_RESP_TIMEOUT;
+        goto exit;
+    }
+    
+    // determine how many respose bytes to fetch
+    {
+        unsigned char rbytes;
+        
+        switch (GET_SDREQ_RESP_TYPE(pReq->Flags)) {
+
+        case SDREQ_FLAGS_RESP_R2:
+            rbytes=SPI_R2_RESPONSE_BYTES;//2
+            break;
+        case SDREQ_FLAGS_RESP_R3:
+            rbytes=SPI_R3_RESPONSE_BYTES; //5
+            break;
+        case SDREQ_FLAGS_RESP_SDIO_R4:
+            rbytes=SPI_SDIO_R4_RESPONSE_BYTES;//5
+            //rbytes=6;
+            break;
+        case SDREQ_FLAGS_RESP_SDIO_R5: 
+            rbytes=SPI_SDIO_R5_RESPONSE_BYTES; //2
+            //rbytes=6;
+            break;    
+    //    case SDREQ_FLAGS_RESP_R1 :
+    //    case SDREQ_FLAGS_RESP_R1b:
+    //        rbytes=1;break;
+        default:
+            rbytes=SPI_R1_RESPONSE_BYTES;//1
+        }
+        
+        
+        for (i = 1; i < rbytes; i++) {
+            r = spi_io(0xff);
+            pReq->Response[i] = r;
+            //DBG_PRINT(DBG_VERBOSE, ("SDIO RESPBYTE:%X \n", r));
+        }
+    }
+    
+    status=SDIO_CheckResponse(pHcd, pReq, SDHCD_CHECK_SPI_TOKEN);    
+
+    if (SDIO_SUCCESS(status) && (pReq->Flags & SDREQ_FLAGS_DATA_TRANS)) {
+        UINT32 block,pos;
+        PUINT8 pBuf = (PUINT8) pReq->pDataBuffer;
+        DBG_ASSERT(pBuf != NULL);    
+        
+        status = SDIO_CheckResponse(pHcd, pReq, SDHCD_CHECK_DATA_TRANS_OK);
+        // check the response to see if we should continue with data
+         if (!(SDIO_SUCCESS(status)))
+                goto exit;
+                
+        /* set block length */
+        //pReq->DataRemaining = pReq->BlockLen * pReq->BlockCount;
+        DBG_PRINT(DBG_VERBOSE,
+                  ("SDIO GPIO %s Data Transfer, Blocks:%d, BlockLen:%d, Total:%d \n",
+                   IS_SDREQ_WRITE_DATA(pReq->Flags) ? "TX" : "RX",
+                   pReq->BlockCount, pReq->BlockLen, pReq->DataRemaining));
+        /* use the context to hold where we are in the buffer */
+            //pReq->pHcdContext = pBuf;//XXXXXXXXXXXXXXuseless
+
+    //    spi_io(0xff);    //1byte recovery time
+            
+        //data trasfer
+
+        //wait for unbusy
+#define WAITBUSY()     do {                                                     \
+                        for (i = 0; i < BUSYTIMEOUTLOOPS; i++)    {            \
+                            r = spi_io(0xff);                                \
+                            if (r!=0x00) break;                                \
+                            yield();                                        \
+                        }                                                     \
+                        DBG_PRINT(DBG_VERBOSE, ("SDIO GPIO: card being busy %i rounds\n",i))\
+                        if (r == 0x00) {                                    \
+                        DBG_PRINT(DBG_ERROR, ("SDIO GPIO: busy timeout after %i rounds\n",i))\
+                            status = SDIO_STATUS_BUS_RESP_TIMEOUT;            \
+                            goto exit;                                        \
+                        }                                                     \
+                    } while (0);
+
+        if (IS_SDREQ_WRITE_DATA(pReq->Flags)) {    //WRITE BLOCKS
+            for (block = 0; block < (pReq->BlockCount); block++) {
+            #ifdef DEBUG
+                if (DBG_VERBOSE_DATA <= DBG_GET_DEBUG_LEVEL())
+                    SDLIB_PrintBuffer(pBuf, pReq->BlockLen, "#write block data#");
+            #endif
+                          
+                spi_io(0xff);    //1byte recovery time
+
+                if (pReq->Command == CMD25)
+                    spi_io(0xfc);
+                else
+                    spi_io(0xfe);    //data token
+
+            #ifdef DEBUG
+                debuglevel--;
+            #endif
+                    
+                //WRITE BLOCK
+                for (pos = 0; pos < pReq->BlockLen; pos++) {
+                #ifdef DEBUG                    
+                    if ((pos<5) ||(pos>pReq->BlockLen-5))
+                        DBG_PRINT(DBG_VERBOSE, ("SDIO GPIO: write pos=%d pBuf=%p *pBuf=%02X\n", pos,pBuf,*pBuf));
+                #endif
+
+                #ifdef SDIO_HCD_CHECK_ZERO_PATTERN 
+                if (pos == 0)
+                    errorcnt=0;
+                if ((*pBuf !=0) && (errorcnt < 10)) {
+                    DBG_PRINT(DBG_ERROR - 1, ("SDIO GPIO: no ZERO_PATTERN: pos=%i buf=%p *buf=%X arg:%x block=%i \n",pos,pBuf,*pBuf,pReq->Argument,block));
+                    errorcnt++;
+                }
+                #endif
+                
+                #ifdef SDIO_HCD_CHECK_IOT_PATTERN 
+                if ((pos % 4) == 0) {
+                    if (pos == 0) {
+                        iot = (pReq->Argument / 512) + block;
+                        errorcnt=0;
+                    }  else    
+                        iot += 0x01010101;
+                    if (iot != *((PUINT32) pBuf)) {
+                        //printk("X");
+                        errorcnt++;
+                        if (errorcnt < 10) {
+                            DBG_PRINT(DBG_ERROR - 1, ("SDIO GPIO: no IOT_PATTERN: pos=%i iot=%X buf=%p *buf=%X arg:%x block=%i \n",pos,iot,pBuf,*((PUINT32) pBuf),pReq->Argument,block));
+                        }
+                        if (errorcnt == 10)
+                            DBG_PRINT(DBG_ERROR - 1, ("SDIO GPIO: no IOT_PATTERN ....\n"));
+                    }    
+                }
+                #endif
+            
+                    //spi_io_wr(*pBuf++);
+                #ifndef SDIO_HCD_WRITE_DEBUGPATTERN    
+                    spi_io(*pBuf);   // do not spi_io(*pBuf++); because of ugly side effects of the spi_io macro
+                #else
+                    spi_io('O');
+                    if (*pBuf != 'O') printk("x");
+                #endif
+                    pBuf++;
+                }
+
+            #ifdef DEBUG
+                debuglevel++;
+            #endif
+                    
+                spi_io(0xff);    spi_io(0xff);     //CRC
+
+                //get data respose
+                r = spi_io(0xff);
+                for (i = 0; i < SDIO_SPI_NCR; i++) {
+                    if (r != 0xff)
+                        break;
+                    r = spi_io(0xff);
+                }
+                if (r == 0xff) {
+                    status = SDIO_STATUS_BUS_RESP_TIMEOUT;
+                    DBG_PRINT(DBG_ERROR, ("SDIO GPIO: TIMEOUT waiting for DATA RESPOSE (blockwrite)\n"));
+                    goto stoptoken;
+                }
+                
+                if ((r & 0x1F) != 0x05) {
+                    status = SDIO_STATUS_DATA_ERROR_UNKNOWN;    //ERROR
+                    DBG_PRINT(DBG_ERROR, ("SDIO GPIO:  DATA ERROR TOKEN r=%02X (blockwrite)\n",r));
+                    goto stoptoken;
+                }
+
+                //TODO: asynchronous wait for unbusy 
+                WAITBUSY();
+            }
+            
+            stoptoken:
+            if (pReq->Command == CMD25) {
+                spi_io(0xfd);    //data stop token
+                spi_io(0xff);    //one byte recovery time
+                WAITBUSY();        //wait for unbusy                                       
+            }
+
+        } else {                //READ BLOCKS
+            for (block = 0; block < (pReq->BlockCount); block++) {
+                for (i = 0; i < BUSYTIMEOUTLOOPS; i++) {    //wait for next data token
+                    r = spi_io(0xff);
+                    if (r != 0xff) {
+                        if ((r & 0x83)  != 0x82) {    //no data start token -> ERROR TOKEN
+                            DBG_PRINT(DBG_ERROR, ("SDIO GPIO: NO START TOKEN r=%02X (blockread)\n",r));
+                            status = SDIO_STATUS_DATA_ERROR_UNKNOWN;    //       ERROR
+                            goto exit;
+                        }
+                        break;
+                        //...
+                    }
+                }
+                if (r == 0xff) {
+                    status = SDIO_STATUS_BUS_RESP_TIMEOUT;
+                    DBG_PRINT(DBG_ERROR, ("SDIO GPIO: TIMEOUT waiting for START TOKEN (blockread)\n"));
+                    goto exit;
+                }
+                //READ BLOCK                                    
+            #ifdef DEBUG
+                debuglevel--;
+            #endif
+                for (pos = 0; pos < (pReq->BlockLen); pos++) {
+                    r = spi_io(0xff);
+
+            #ifdef DEBUG                    
+                    if ((pos<5) ||(pos>pReq->BlockLen-5))
+                        DBG_PRINT(DBG_VERBOSE, ("r=%02X pos=%d pBuf=%p *pBuf=%02X\n",r, pos,pBuf,*pBuf));
+            #endif
+                    *pBuf++ = r;
+                }
+        
+            #ifdef DEBUG
+                debuglevel++;
+        
+                if (DBG_VERBOSE_DATA <= DBG_GET_DEBUG_LEVEL())
+                    SDLIB_PrintBuffer(pBuf - pReq->BlockLen,pReq->BlockLen, "#read block data#");
+            #endif
+            
+                spi_io(0xff);spi_io(0xff);    //CRC
+            }
+            
+            if ( pReq->Flags & SDREQ_FLAGS_AUTO_CMD12) {
+                
+                // automatically issuing CMD12 to stop multipl. block read 
+                spi_io(0x40 | 12);
+                //ARGUMENT
+                spi_io(0x00);
+                spi_io(0x00);
+                spi_io(0x00);
+                spi_io(0x00);
+                spi_io(0xff); // CRC
+                //stuffed byte -> ignore
+                spi_io(0xff);
+                
+                //catch response
+                r = spi_io(0xff);
+                for (i = 0; i < SDIO_SPI_NCR; i++) {
+                    if (!(r & 0x80))
+                        break;
+                    r = spi_io(0xff);
+                }
+                DBG_PRINT(DBG_VERBOSE,
+                ("SDIO HCD GPIO - AUTO CMD12 r=%02X\n",r));
+                
+                WAITBUSY();
+            }    
+        }
+    } 
+
+  exit:
+    // check status
+    
+    spi_cs_hi();
+    //WAIT (???)
+    for (i = 0; i < 8; i++)
+        spi_io(0xff);
+    DBG_PRINT(((SDIO_SUCCESS(status)) ? DBG_VERBOSE:DBG_ERROR),
+              ("SDIO GPIO pHcd=%p (RespType:%d, Command:0x%0X , Arg:0x%0X, Resp[0]:0x%0X, Status:%i) \n",
+               pHcd, GET_SDREQ_RESP_TYPE(pReq->Flags), pReq->Command,
+                pReq->Argument,pReq->Response[0],status));
+    
+    pReq->Status = status;
+    
+    if (status != SDIO_STATUS_PENDING) {
+        // request was completed inline or failed for whatever reason
+        if (IS_SDREQ_FORCE_DEFERRED_COMPLETE(pReq->Flags)) {
+            DBG_PRINT(DBG_VERBOSE,
+                      ("SDIO HCD - SDREQ_FLAGS_FORCE_DEFERRED_COMPLETE (%d)\n",
+                       pReq->Flags));
+            // queue a work item to make the indication
+            schedule_work(&deferred_complete);
+            // always return status pending
+            status = SDIO_STATUS_PENDING;
+        }
+        // fall through and return completion status, we completed this in-line  
+    }
+    
+    #ifdef DEBUG
+    if (pReq->Command == 0x0D) 
+        debuglevel += 3;
+    #endif
+    
+    //pReq->Status = status;
+    
+    return status;
+}
+
+
+SDIO_STATUS HcdConfig(PSDHCD pHcd, PSDCONFIG pConfig)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    UINT16 command;
+    UINT16 i;
+
+    command = GET_SDCONFIG_CMD(pConfig);
+
+    DBG_PRINT(DBG_VERBOSE,
+              ("SDIO GPIO Local HCD: HcdConfig - command: 0x%X\n",
+               command));
+
+    switch (command) {
+    case SDCONFIG_GET_WP:
+        return (0);
+        break;
+    case SDCONFIG_SEND_INIT_CLOCKS:
+        /* should be at least 80 clocks at our lowest clock setting */
+        spi_cs_hi();
+        spi_out_hi();
+        spi_writeout();
+
+        for (i = 0; i < SDMMC_MIN_INIT_CLOCKS; i++) {
+            spi_clk_hi();
+            spi_writeout();
+            //SPI_DELAY(2);
+            //udelay(3);
+            spi_clk_lo();
+            spi_writeout();
+            //udelay(3);
+            //SPI_DELAY(2);
+        }
+        break;
+    case SDCONFIG_SDIO_INT_CTRL:
+
+        break;
+    case SDCONFIG_SDIO_REARM_INT:
+        break;
+    case SDCONFIG_BUS_MODE_CTRL:
+        {
+            PSDCONFIG_BUS_MODE_DATA pBusMode =
+                      GET_SDCONFIG_CMD_DATA(PSDCONFIG_SDIO_INT_CTRL_DATA,pConfig);
+            pBusMode->ActualClockRate=CLKRATE;
+        }
+        break;
+    case SDCONFIG_POWER_CTRL:
+        break;
+    default:
+        /* invalid request */
+        DBG_PRINT(SDDBG_ERROR,
+                  ("SDIO GPIO Local HCD: HcdConfig - bad command: 0x%X\n",
+                   command));
+        status = SDIO_STATUS_INVALID_PARAMETER;
+    }
+    return status;
+}
diff -uNr empty/empty/empty/src/drivers/sdio/hcd/gpio/sdio_gpio.h packages/utils/sdio/src/drivers/sdio/hcd/gpio/sdio_gpio.h
--- empty/empty/empty/src/drivers/sdio/hcd/gpio/sdio_gpio.h    1970-01-01 01:00:00.000000000 +0100
+++ packages/utils/sdio/src/drivers/sdio/hcd/gpio/sdio_gpio.h    2007-04-23 11:12:35.662526400 +0200
@@ -0,0 +1,168 @@
+#ifndef __SDIO_HCD_LINUX_H___
+#define __SDIO_HCD_LINUX_H___
+
+#include <linux/kernel.h>
+#include <linux/sdio/ctsystem.h>
+#include <linux/sdio/sdio_busdriver.h>
+#include <linux/sdio/sdio_lib.h>
+#include <linux/sdio/_sdio_defs.h>
+#include <linux/workqueue.h>
+#include <linux/sched.h>
+//#include <linux/delay.h>
+
+
+static int __init sdio_hcd_init(void) ;
+static void __exit sdio_hcd_cleanup(void);
+#define DESCRIPTION "SDIO GPIO HCD DRIVER"
+
+
+#ifndef CONFIG_KMOD_MMC_GPIO_DI 
+#define CONFIG_KMOD_MMC_GPIO_DI 1
+#warning "using default GPIO_DI"
+#endif
+#ifndef CONFIG_KMOD_MMC_GPIO_DO 
+#define CONFIG_KMOD_MMC_GPIO_DO 3
+#warning "using default GPIO_DO"
+#endif
+#ifndef CONFIG_KMOD_MMC_GPIO_CLK 
+#define CONFIG_KMOD_MMC_GPIO_CLK 4
+#warning "using default GPIO_CLK"
+#endif
+#ifndef CONFIG_KMOD_MMC_GPIO_CS
+#define CONFIG_KMOD_MMC_GPIO_CS 7
+#warning "using default GPIO_CS"
+#endif
+
+#define SD_DI (1 << (CONFIG_KMOD_MMC_GPIO_DI))
+#define SD_DO  (1 << (CONFIG_KMOD_MMC_GPIO_DO))
+#define SD_CLK (1 << (CONFIG_KMOD_MMC_GPIO_CLK))
+#define SD_CS  (1 << (CONFIG_KMOD_MMC_GPIO_CS))
+
+
+#define SPI_DELAY_FACTOR 0
+#define DBG_ERROR (SDDBG_TRACE - 2)
+#define DBG_VERBOSE (SDDBG_TRACE - 1)
+#define DBG_VERBOSE_DATA (SDDBG_TRACE + 0)
+#define DBG_VERBOSE_SPI_DATA (SDDBG_TRACE + 1)
+#define BUSYTIMEOUTLOOPS 7000
+#define SDIO_SPI_NCR 16  // double of spec.
+#define CLKRATE 19500000 /* 19.5 Mhz */
+
+#if 0  //ARCH: ATHEROS   
+
+u32 port_state;
+
+#include "ar531x.h"
+#define refresh_gpio_state() port_state=sysRegRead(AR5315_GPIO_DO)
+#define spi_out_hi() port_state |= SD_DI
+#define spi_out_lo() port_state &= ~SD_DI
+#define spi_clk_hi() port_state |= SD_CLK
+#define spi_clk_lo() port_state &= ~SD_CLK
+#define spi_writeout() {sysRegWrite(AR5315_GPIO_DO,port_state);}
+#define spi_cs_lo()     {port_state  &= ~(SD_CS);    spi_writeout();}
+#define spi_cs_hi()     {port_state |= SD_CS ;        spi_writeout();}
+#define spi_cs_state()            ((port_state &  SD_CS) ? 1 : 0 )
+#define spi_read() (sysRegRead(AR5315_GPIO_DI) & (SD_DO))
+
+#define spi_gpio_init()    {     port_state=sysRegRead(AR5315_GPIO_CR);                 \
+                            port_state &= ~(SD_DO);                             \
+                            port_state |= SD_DI | SD_CLK | SD_CS;                 \
+                            sysRegWrite(AR5315_GPIO_CR,port_state);                \
+                            refresh_gpio_state();                            }
+                        
+#define spi_gpio_cleanup()
+#endif
+
+
+
+#if 1  //ARCH: ATHEROS   
+//TEST for read_modify_write performace
+
+#include "ar531x.h"
+#define refresh_gpio_state() do {} while(0)
+#define spi_writeout() do {} while(0)
+#define spi_out_hi() sysRegWrite(AR5315_GPIO_DO,sysRegRead(AR5315_GPIO_DO) | (SD_DI))
+#define spi_out_lo() sysRegWrite(AR5315_GPIO_DO,sysRegRead(AR5315_GPIO_DO) & ~(SD_DI))
+#define spi_clk_hi() sysRegWrite(AR5315_GPIO_DO,sysRegRead(AR5315_GPIO_DO) | (SD_CLK))
+#define spi_clk_lo() sysRegWrite(AR5315_GPIO_DO,sysRegRead(AR5315_GPIO_DO) & ~(SD_CLK))
+#define spi_cs_hi()     sysRegWrite(AR5315_GPIO_DO,sysRegRead(AR5315_GPIO_DO) | (SD_CS))
+#define spi_cs_lo()     sysRegWrite(AR5315_GPIO_DO,sysRegRead(AR5315_GPIO_DO) & ~(SD_CS))
+#define spi_cs_state()            ((sysRegRead(AR5315_GPIO_DO) &  SD_CS) ? 1 : 0 )
+#define spi_read() (sysRegRead(AR5315_GPIO_DI) & (SD_DO))
+
+#define spi_gpio_init()    {     u32 port_state;                                        \
+                            port_state=sysRegRead(AR5315_GPIO_CR);                 \
+                            port_state &= ~(SD_DO);                             \
+                            port_state |= SD_DI | SD_CLK | SD_CS;                 \
+                            sysRegWrite(AR5315_GPIO_CR,port_state);                \
+                            }
+                        
+#define spi_gpio_cleanup()
+#endif
+
+
+#if 0  //ARCH: BROADCOM
+
+u32 port_state;
+
+static volatile uint32 *gpioaddr_input = (uint32 *)0xb8000060;
+static volatile uint32 *gpioaddr_output = (uint32 *)0xb8000064;
+static volatile uint32 *gpioaddr_enable = (uint32 *)0xb8000068;
+static volatile uint32 *gpioaddr_control = (uint32 *)0xb800006c;
+
+#define GPIO_DIR_IN 1
+
+#define spi_writeout()     *gpioaddr_output = port_state
+#define spi_read() ((*gpioaddr_input)& SD_DO)
+#define spi_out_hi() port_state |= SD_DI
+#define spi_out_lo() port_state &= ~SD_DI
+#define spi_clk_hi() port_state |= SD_CLK
+#define spi_clk_lo() port_state &= ~SD_CLK
+#define spi_cs_lo()     {port_state  &= ~(SD_CS);    spi_writeout();}
+#define spi_cs_hi()     {port_state |= SD_CS ;        spi_writeout();}
+#define spi_cs_state()            ((port_state &  SD_CS) ? 1 : 0 )
+#define refresh_gpio_state() port_state=*gpioaddr_output
+#define spi_gpio_init()    {     port_state=*gpioaddr_control;                 \
+                            port_state |= (SD_DO);                         \
+                            port_state &= ~(SD_DI | SD_CLK | SD_CS);     \
+                            *gpioaddr_control=port_state;                \
+                            refresh_gpio_state();                            }                        
+#define spi_gpio_cleanup()    
+#endif
+
+
+#if ((SPI_DELAY_FACTOR) != 0)
+    #define SPI_DELAY(__TIME) udelay(__TIME*SPI_DELAY_FACTOR)
+    //#define SPI_DELAY(__TIME) mdelay((__TIME)*(SPI_DELAY_FACTOR))
+#else
+    #define SPI_DELAY(__TIME)
+#endif
+
+#define spi_io(XX) (((XX)==0xff) ? spi_io_ff() : spi_io_wr((XX)))  //ATTENTION: side effects !
+
+
+typedef struct _SDHCD_DEVICE {
+    UINT8 dummy;
+//    OS_PNPDEVICE   HcdDevice;     /* the OS device for this HCD */
+//    OS_PNPDRIVER   HcdDriver;     /* the OS driver for this HCD */
+ 
+}SDHCD_DEVICE, *PSDHCD_DEVICE;
+
+
+/* driver wide data, this driver only supports one device,
+ * so we include the per device data here also */
+typedef struct _SDHCD_DRIVER_CONTEXT {
+    PTEXT         pDescription;       /* human readable device decsription */
+    SDHCD         Hcd;                /* HCD description for bus driver */
+//    SDHCD_DEVICE  Device;             /* the single device's info */
+ 
+}SDHCD_DRIVER_CONTEXT, *PSDHCD_DRIVER_CONTEXT;
+
+
+static unsigned char spi_io_ff(void);
+static unsigned char spi_io_wr(unsigned char data_out);
+SDIO_STATUS HcdRequest(PSDHCD pHcd);
+SDIO_STATUS HcdConfig(PSDHCD pHcd, PSDCONFIG pConfig);
+
+#endif
+
